{% import "macros/common_macros.html" as common_macros %}
{% import "macros/relations_macros.html" as relations %}

{% extends "base.html" %}

{% block body_class %}resources-events{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', path='/css/overlay.css') }}?v={{ get_setting('version') }}">
<script type="module">
    import { activateOverlay } from "/static/js/overlay.js";
    activateOverlay();
</script>
{% endblock head %}

{% block content %}

{% include "includes/main_title.html" %}

<p>
    <a href="/search?events={{ meta['id_real'] }}">Vis alle resultater i samlingen</a>
</p>

{% set keys = [
"id", "ext_data_season", "ext_data_stagename", "date_from_premier", "ext_data_playwright", "ext_data_original_id",
"ext_data_production", "event_type", "addr_nr", "zipcode", "latitude_longitude", "parish", "rotation", "local_area"] %}

{% set options = {'icon': schema, 'icon_label': 'Lokation'} %}
{{ common_macros.parse_image_block('Stamdata', keys, resource, options) }}

{% set keys = ["ext_data_translater", "ext_data_arkiv_id", "ext_data_number_of_performances"] %}
{{ common_macros.parse_block_common('Beskrivelse', keys, resource) }}

{% set keys = ["sources_normalized"] %}
{{ common_macros.parse_block_common('Kilder', keys, resource) }}

{{ relations.parse_relations('people', resource) }}

{% set meta_links = [
{"url": "/events/" + meta['id_real'] + "/json/api", "label": "JSON. Resource fra API" },
{"url": "/events/" + meta['id_real'] + "/json/resource_and_types", "label": "JSON. Typer og værdier" }
] %}

{{ common_macros.parse_meta_block(meta_links) }}

<div class="app"></div>

<style>
    .search-suggestions {
        position: absolute;
        background-color: whitesmoke;
        display: none;
        padding: 5px;
        width: 295px;
        max-height: calc(100vh - 150px);
        overflow-y: auto;
    }


    .search-suggestion-item,
    .search-suggestion-info {
        flex: 2;
        padding: 5px;
        border-bottom: 1px solid #ccc;
    }

    .search-suggestion-focus {
        background-color: white;
    }
</style>

<script>
    // import { Requests } from "/static/js/requests.js";
    // import { Flash } from "/static/js/flash.js";
    // import { showErrorMessages, getEditor } from "/static/js/jsoneditor-utils.js";
    // import { setLocalStorage, getLocalStorage, removeLocalStorage } from '/static/js/local-storage-ttl.js'
    // import { html, render } from '/static/js/lit-core.min.js';
</script>

<script type="module">
    import { html, render } from 'https://cdn.jsdelivr.net/npm/lit-html/lit-html.js';
    import { AutoComplete } from '/static/js/auto-complete.js';
    import { Flash } from '/static/js/flash.js';
    import { Requests } from "/static/js/requests.js";

    // Assuming 'relations' variable is already populated with the JSON data
    const resource = {{ to_json(resource) | safe }};
    const resource_original = resource.resource_orginal
    
    let relations = resource.relations;
    let state = {}
    let currentData = []

    console.log(relations)

    // Render the autocomplete suggestions as HTML
    const renderFunction = (data) => {

        currentData = data;

        // Info if no results
        if (data.length == 0) return `<div class="search-suggestion-info">Ingen forslag. Tryk på søgeknappen for at fritekstsøge i stedet.</div>`;

        // Help text and suggestions
        const suggestionHelp = `<div class="search-suggestion-info">Vælg et forslag nedenfor <strong>eller</strong> tryk på søgeknappen for at fritekstsøge.</div>`;

        // Suggestions
        const suggestions = data.map(function (item) {

            return `
                <div class="search-suggestion-item" data-id="${item.id}" data-text="">
                    <div>
                        <a href="/${item.domain}/${item.id}">${item.display}</a>
                    </div>
                    <div>${item.sub_display}</div>
                </div>`;
        }).join('');

        return `${suggestionHelp} ${suggestions}`;
    };

    // Function to run when a suggestion is selected (On return)
    const returnFunction = (data) => {
        const autocompleteElem = document.querySelector('.typeahead');

        let id = data.dataset.id
        // Set the value of the input field
        let selectedItem = currentData.find(item => item.id == id)
        
        const displayValue = selectedItem.display;
        autocompleteElem.value = displayValue;

        // Get object id elem from form and set value
        const objectIdElem = document.querySelector('input[name="object_id"]');
        objectIdElem.value = id;

        // Get object domain elem from form and set value
        const objectDomainElem = document.querySelector('input[name="object_domain"]');
        objectDomainElem.value = selectedItem.domain;
    }   

    function autoCompleteInit() {
        const autocompleteElem = document.querySelector('.typeahead');
        const suggestionsElem = document.querySelector('.search-suggestions');

        const options = {
            'autocompleteElem': autocompleteElem,
            'suggestionsElem': suggestionsElem,
            'renderFunction': renderFunction,
            'endpoint': `/auto_complete?q=`,
            'minInputLength': 2,
            'suggestionFocusClass': 'search-suggestion-focus',
            'returnFunction': returnFunction,
            'debug': true,
        }

        new AutoComplete(options);

    }


    const renderForm = function (section, index) {

        let relStart = '';
        let relEnd = '';
        if (resource_original.domain === 'events' && resource_original.date_from) {
            relStart = html`<input type="hidden" name="rel_start" value="${resource_original.date_from}">`;
        }
        if (resource_original.domain === 'events' && resource_original.date_to) {
            relEnd = html`<input type="hidden" name="rel_end" value="${resource_original.date_to}">`;
        }

        return html`
      <form id="relation-form" @submit=${submitForm}>
        <input type="hidden" name="subject_domain" value="${resource_original.domain}">
        <input type="hidden" name="subject_id" value="${resource_original.id}">
        <input type="hidden" name="object_domain">
        <input type="hidden" name="object_id">
        ${relStart}
        ${relEnd}
        <label for="rel_label" class="float_left">Relationslabel</label>
        <input type="text" name="rel_label" class="float_left">
        <label for="object_label" class="float_left">Relationsobjekt</label>
        <input class="typeahead" name="object_label" type="text" autocomplete="off" placeholder="Find entitet">
        <button type="submit">Opret relation</button>
        <div class="search-suggestions"></div>
    `;
    }

    // Render a single section of the relations array
    const renderRelationSection = (section, index) => html`
      <div class="record-section" style="background-color: lightcyan">
        <div class="record-main">
          <h3 class="record-header">${section.label}<span data-id="${index}" @click=${showForm}> + relation </span> </h3>
            ${state.formShow == index ? renderForm(section, index) : ''}
            ${section.data.map(item => html`
                <div class="record-content">
                <div class="label">${item.rel_label}</div>
                <div class="content">
                    <p>
                    <a href="/people/${item.id}">${item.display_label}</a>
                    </p>
                </div>
                </div>
            `)}
        </div>
      </div>
    `;

    const showForm = {
        handleEvent(e) {
            let id = e.target.dataset.id;
            state.formShow = id
            renderRelationsMain();
            autoCompleteInit();

            let relationForm = document.getElementById('relation-form');
            relationForm.addEventListener('submit', function (e) {
                e.preventDefault();
            })
        }
    }

    async function fetchRelations() {
        let url = `/relations/${resource_original.domain}/${resource_original.id}`;

        let options = {
            method: 'GET',
            headers: {
                'Accept': 'application/json'
            }
        }

        try {
            let result = Requests.asyncGetJson(url, options);
            return result
        } catch (error) {
            Flash.setMessage('Kunne ikke opdatere relationer', 'error');
            console.error(error);
        }
    }

    const submitForm = {
        async handleEvent(e) {
            e.preventDefault();
            let form = e.target;
            let data = new FormData(form);
            let url = '/relations';
            let options = {
                method: 'POST',
                body: data
            }
            
            try {
                const result = await Requests.asyncPost(url, data)
                if (result.error) {
                    console.log(result)
                    throw new Error(result.message);
                }

                state.formShow = null;
                Flash.setMessage('Relationen er oprettet', 'success');
                relations = await fetchRelations();
                console.log(relations)
                renderRelationsMain();
            } catch (error) {
                Flash.setMessage("Relationen kunne ikke oprettes. Der skal være en label og et objekt", 'error');
                console.error(error);
            }
        }
    }

    // Iterate over the relations and render each section    
    const renderRelationSections = (relations) => html`
        ${relations.map((section, index) => renderRelationSection(section, index))}
    `;

    // Render the app
    function renderRelationsMain() {
        render(renderRelationSections(relations), document.querySelector('.app'));
    }

    renderRelationsMain();
</script>


<!-- {{ pre(resource.relations)|safe}} -->

{% endblock content %}